1、常用设计模式
单例模式：懒汉式、饿汉式、双重校验锁、静态加载，内部类加载、枚举类加载。保证一个类仅有一个实例，并提供一个访问它的全局访问点。
代理模式：动态代理和静态代理，什么时候使用动态代理。
适配器模式：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
装饰者模式：动态给类加功能。
观察者模式：有时被称作发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。
策略模式：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
外观模式：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
命令模式：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。
创建者模式：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
2、基础知识
Java基本类型哪些，所占字节和范围
Set、List、Map的区别和联系
解答：如果你经常会使用索引来对容器中的元素进行访问，那么 List 是你的正确的选择。如果你已经知道索引了的话，那么 List 的实现类比如 ArrayList 可以提供更快速的访问,如果经常添加删除元素的，那么肯定要选择LinkedList。
如果你想容器中的元素能够按照它们插入的次序进行有序存储，那么还是 List，因为 List 是一个有序容器，它按照插入顺序进行存储。
如果你想保证插入元素的唯一性，也就是你不想有重复值的出现，那么可以选择一个 Set 的实现类，比如 HashSet、LinkedHashSet 或者 TreeSet。所有 Set 的实现类都遵循了统一约束比如唯一性，而且还提供了额外的特性比如 TreeSet 还是一个 SortedSet，所有存储于 TreeSet 中的元素可以使用 Java 里的 Comparator 或者 Comparable 进行排序。LinkedHashSet 也按照元素的插入顺序对它们进行存储。
如果你以键和值的形式进行数据存储那么 Map 是你正确的选择。你可以根据你的后续需要从 Hashtable、HashMap、TreeMap 中进行选择。
什么时候使用Hashmap
什么时候使用Linkedhashmap、Concurrenthashmap、Weakhashmap
哪些集合类是线程安全的
为什么Set、List、map不实现Cloneable和Serializable接口
Concurrenthashmap的实现，1.7和1.8的实现
Arrays.sort的实现
什么时候使用CopyOnArrayList
volatile的使用
synchronied的使用
reentrantlock的实现和Synchronied的区别
CAS的实现原理以及问题
AQS的实现原理
接口和抽象类的区别，什么时候使用
类加载机制的步骤，每一步做了什么，static和final修改的成员变量的加载时机
双亲委派模型
反射机制：反射动态擦除泛型、反射动态调用方法等
动态绑定：父类引用指向子类对象
JVM内存管理机制：有哪些区域，每个区域做了什么
JVM垃圾回收机制：垃圾回收算法 垃圾回收器 垃圾回收策略
jvm参数的设置和jvm调优
什么情况产生年轻代内存溢出、什么情况产生年老代内存溢出
内部类：静态内部类和匿名内部类的使用和区别
Redis和memcached：什么时候选择redis，什么时候选择memcached，内存模型和存储策略是什么样的
MySQL的基本操作 主从数据库一致性维护
mysql的优化策略有哪些
mysql索引的实现 B+树的实现原理
什么情况索引不会命中，会造成全表扫描
java中bio nio aio的区别和联系
为什么bio是阻塞的 nio是非阻塞的 nio是模型是什么样的
Java io的整体架构和使用的设计模式
Reactor模型和Proactor模型
http请求报文结构和内容
http三次握手和四次挥手
rpc相关：如何设计一个rpc框架，从io模型 传输协议 序列化方式综合考虑
Linux命令 统计，排序，前几问题等
StringBuff 和StringBuilder的实现，底层实现是通过byte数据，外加数组的拷贝来实现的
cas操作的使用
内存缓存和数据库的一致性同步实现
答：（a）发生了写请求A，A的第一步淘汰了cache（如上图中的1）

	（b）A的第二步写数据库，发出修改请求（如上图中的2）

	（c）发生了读请求B，B的第一步读取cache，发现cache中是空的（如上图中的步骤3）

	（d）B的第二步读取数据库，发出读取请求，此时A的第二步写数据还没完成，读出了一个脏数据放入cache（如上图中的步骤4）

	即在数据库层面，后发出的请求4比先发出的请求2先完成了，读出了脏数据，脏数据又入了缓存，缓存与数据库中的数据不一致出现了

微服务的优缺点
线程池的参数问题
ip问题 如何判断ip是否在多个ip段中
判断数组两个中任意两个数之和是否为给定的值
乐观锁和悲观锁的实现
synchronized实现原理
你在项目中遇到的困难和怎么解决的
你在项目中完成的比较出色的亮点
消息队列广播模式和发布/订阅模式的区别
生产者消费者代码实现
死锁代码实现
线程池：参数，每个参数的作用，几种不同线程池的比较，阻塞队列的使用，拒绝策略
Future和ListenableFuture 异步回调相关
算法相关：判断能否从数组中找出两个数字和为给定值，随机生成1~10000不重复并放入数组，求数组的子数组的最大和，二分查找算法的实现及其时间复杂计算
3、其它
算法：常用排序算法，二分查找，链表相关，数组相关，字符串相关，树相关等
常见序列化协议及其优缺点
memcached内存原理，为什么是基于块的存储
搭建一个rpc需要准备什么
如果线上服务器频繁地出现full gc ，如何去排查
如果某一时刻线上机器突然量变得很大，服务扛不住了，怎么解决
LUR算法的实现
LinkedHashMap实现LRU
定义栈的数据结构，请在该类型中实现一个能够找到栈最小元素的min函数
海量数据处理的解决思路
reactor模型的演变
阻塞、非阻塞、同步、异步区别
Collection的子接口
jvm调优相关
zookeeper相关，节点类型，如何实现服务发现和服务注册
nginx负载均衡相关，让你去实现负载均衡，该怎么实现
linux命令，awk、cat、sort、cut、grep、uniq、wc、top等
压力测试相关，怎么分析，单接口压测和多情况下的压测
你觉得你的有点是什么，你的缺点是什么
spring mvc的实现原理
netty底层实现，IO模型，ChannelPipeline的实现和原理
缓存的设计和优化
缓存和数据库一致性同步解决方案
你所在项目的系统架构，谈谈整体实现
消息队列的使用场景
ActiveMQ、RabbitMQ、Kafka的区别
------------------------------------------------------------------------------------------------------------------------------------------------------------
重点知识
   由于我面试的Java开发工程师，针对于JAVA，需要理解的重点内容有：

       JVM内存管理机制和垃圾回收机制（基本每次面试都会问，一定要搞得透彻）

       JVM内存调优（了解是怎么回事，一般做项目过程中使用较多）

       设计模式（熟悉常见设计模式的应用场景，会画类图，实在不行背几个也是有用的）

       多线程（每次都会问，包括线程和进程、线程状态、线程并发的操作等，需要深入复习）

       JAVA集合类框架（理解框架图、HashMap、ArrayList、HashSet等的关系和区别，其中HashMap的存储机制几乎每次都有问）

       JAVA的异常处理机制（异常的分类、常见的异常有哪些、Try catch finally的使用）

       JVM运行机制（理解JVM是如何运行的）

       Linux基础（面试笔试中对linux也有一定的要求，建议最好搭建一个linux虚拟机，并练习常用的命令）



数据结构和算法
     常见的排序算法就不说了，需要理解其原理和会写代码，还有时间空间复杂度也要知道

     队列、栈：需要理解其存取结构，并能在某些场景下使用

     二叉树：树的遍历、树的深度、按层次输出、平衡二叉树、逆序打印树等

     链表：逆序、合并两有序的链表、判断链表是否又环、链表倒数第K个元素等

     字符串：KMP算法、动态规划（这个是重点，需要好好理解动态规划，常见的题有：求解最长回文子串、求解最长公共子串等）

     海量数据处理：现在好多大公司都会问海量数据的处理，所以需要掌握常见的处理方法，比如Bit-map、分而治之、hash映射等，可以百度看看相关的文章，加深理解



数据库相关（数据库是面试的重点，每家公司都会问）
     最基本的数据库CRUD操作要熟悉，能够根据表写出需要的SQL语句

     事务、零时表、索引、表锁、行列锁、视图、存储过程等都要深入理解

     互联网公司处理的数据量都很大，所以有必要对数据库优化和大数据的处理进行了解和熟悉

     建议看看Nosql和Redis等非关系数据库相关的书籍和资料



开源框架
     像SSH等的开源框架在面试过程中问的很少，但是也是有必要了解SSH的运行原理和使用。面试主要考察的是基础，所以更加偏向于考察数据结构、算法、数据库、JAVA基础知识等。所以，如果你时间有限，可以把精力放在基础知识的学习和复习上，如果你时间充裕，可以学习和复习开源框架相关知识。对于开源框架：最好还是看看源码，对自己的好处是很大的。



个人建议
     上面比较详细地列出和分析了最近面试过程中的问题，由于时间长久，不可能全部都回忆起来，但是大体上相差不大。对于面试，个人的一些建议：

     （1）心态要放好，不能着急。不要看到被人拿到offer，自己没有就抱有心里压力，其实工作谁都可以找到，就看满意不满意，所以着急也是没有用。

     （2）身体很重要。不要熬通宵复习、学习，把身体搞垮了得不偿失。保持良好的睡眠。

     （3）善于总结面试中的问题。每一次笔试、面试完后，需要进行总结，将自己不会的知识点一定要搞清楚，如果不搞清楚，下次还有可能会问的。其实找工作的过程就是积累知识的过 程，所以善于总结很重要。

     （4）不要盲目投递简历。不要看见大公司就投递，也不要投递自己不想去的城市，那样就是在瞎折腾，公司就算要你了，你也不去，还不如把时间放在自己想去的地方呢。

     （5）复习需要持续。由于记忆过后会遗忘，所以复习过程中，需要反复进行，一边理解一边记忆，达到闭上眼就能看见知识的体系结构。



最后，希望找工作的朋友都能找到一份满意的工作。下面具体列出了面试常见的知识点，供大家参考，希望对你有所帮助。

       

主要详细知识点
常用算法考察
冒泡排序

快速排序

插入排序

希尔排序

归并排序

堆排序

桶排序

动态规划

最长公共子串

最长回文子串

数组的最大k个值

数字的最大连续子数组之和

左旋转字符串

字符串匹配算法:KMP算法

二分查找

 

链表
单链表逆序

两个有序单链表合并

两个单链表是否相交

相交处的节点

单链表倒数第K个数

单链表排序

 

栈和队列
设计包含min函数的栈

两个队列实现栈

两个栈实现队列

一个数组实现栈和队列

 

树
前序、中序、后续遍历

求二叉树的深度

按层次遍历二叉树

判断二叉树是否为完全二叉树

判断二叉树是否镜面对称

判断两颗树是否相等

 

卡特兰数
出栈顺序

n个节点构成的二叉树个数

括号化

凸多边形三角划分

 

设计模式
Java源码中有哪些设计模式

http://www.iteye.com/news/18725

常见的设计模式类图

http://blog.sina.com.cn/s/blog_8cc6ff5c0101d4cp.html

常见的设计模式的示例：

http://www.jb51.net/article/27973.htm

 

数据库
数据库的crud语句的书写

数据库优化策略、如何优化

海量数据优化

事务

事务中锁分类

事务特性

数据库表锁

行列锁

临时表

索引

存储空间

视图

 

Linux常用命令（最好实战）
http://www.php100.com/html/webkaifa/Linux/2009/1106/3485.html

 

linux上搭建服务器
http://www.cnblogs.com/dudu/archive/2012/12/09/linux-apache-git.html

 

常用的网络端口
http://www.360doc.com/content/11/1202/09/8209768_169068538.shtml

 

Nosql、redis等的熟悉、了解
http://www.yiibai.com/redis/redis_quick_guide.html

 

海量数据的处理
Bit-map、分而治之、hash映射、分布式处理（Hadoop）、Trie树、双层桶排序等

 

Java基础
HashMap的存储机制（很重要，必看）

Set、map区别

Set、list区别

Arraylist、LinkedList区别

String、Stringbufer、StringBuilder区别

HashSet、LinkedHashSet区别

HashMap、TreeMap、LinkedHashMap

熟悉Java集合类的框架图

HashMap、ArrayList、StringBuffer、String等源码的熟悉

线程和进程

线程的特性

线程的状态

多线程并发的实现

线程的创建方式

线程池的使用

Java作用域

final、static、native、等特殊关键字的使用

Java按值传递的过程

重构和重载

抽象类和接口

内部类的使用：匿名内部类、静态内部类等

Java多线程并发、生产者消费者的实现

Java连接数据库的过程

 

JVM内存管理和存储机制
http://blog.csdn.net/lengyuhong/article/details/5953544

 

JVM垃圾回收机制，垃圾回收算法
http://jbutton.iteye.com/blog/1569746

 

JVM加载类过程
 http://www.cnblogs.com/sunada2005/p/3577799.html

 

JVM内存调优
http://www.cnblogs.com/jackyrong/archive/2010/01/21/1653163.html

http://blog.csdn.net/cutesource/article/details/5907418

 

框架相关
对框架的熟悉:SSH （面试过程中问的很少，像jsp、servlet基本不问）

spring框架组成、AOP、IOC 、用到的设计模式

hibernate运行机制、缓存的使用、最好看看源码

熟悉和了解JavaScript和jQuery

 

java中IO、NIO
Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

 

IO流包括字节流和字符流：

字节流：对应抽象类为InputStream（输入流）和 OutputStream（输出流）。 FileInputStream、FileOutputStream

字符流：对应抽象类为Reader（输入流）和Writer（输出流）。BufferedReader、InputStreamReader、 StringReader

 

java中异常的分类及结构
Java中的异常类，包括内置的异常类以及自定义的异常类，都直接或者间接地继承至java.lang.Throwable类。在java.lang包中，Throwable类有两个直接子类：Error类和Exception类，Error类及其子类描述了java运行时系统的内部错误和资源耗尽错误。出现这样的错误的，除了通知用户，并接尽力使程序安全地终止之外，没有更好的办法。Exception类的层次结构又分为两个分支：一个分支由RuntimeException派生，另外一个分支包含除RuntimeException类之外的异常类。

 

运行时异常、非运行时异常
运行时异常：RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException、classCastException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。

非运行时异常：RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，不处理程序不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常。

 

动态代理机制
动态代理可以提供对另一个对象的访问，同时隐藏实际对象的具体事实。代理一般会实现它所表示的实际对象的接口。代理可以访问实际对象，但是延迟实现实际对象的部分功能，实际对象实现系统的实际功能，代理对象对客户隐藏了实际对象。客户不知道它是与代理打交道还是与实际对象打交道。动态代理主要包含以下角色：动态代理类（以下简称为代理类）是一个实现在创建类时在运行时指定的接口列表的类，该类具有下面描述的行为。代理接口 是代理类实现的一个接口。代理实例 是代理类的一个实例。每个代理实例都有一个关联的调用处理程序 对象，它可以实现接口 InvocationHandler。通过其中一个代理接口的代理实例上的方法调用将被指派到实例的调用处理程序的 Invoke 方法，并传递代理实例、识别调用方法的java.lang.reflect.Method 对象以及包含参数的 Object 类型的数组。调用处理程序以适当的方式处理编码的方法调用，并且它返回的结果将作为代理实例上方法调用的结果返回。

 

try catch finally的使用
1. finally 里 始终会被执行到， System.exit(0); 除这种被执行外。
2. 即使try中有return ，也是先执行 return 后面的语句完了之后，不立马return，而是去执行finally中的语句。

3. 当try中与finally里，同时出现return , 则只会返回 finally 中的return 结果。
4. finally中的值不能影响try中 即将返回的结果值。
注意： 若finally中没有return在try或catch中有return，那么在执行return跟着语句之后，会把语句的结果新开辟一内存空间，直接把结果的存放此内存空间中。所以，finally中的值不能影响try或catch中即将return的结果。

 

静态成员、非静态成员
（1）类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。

（2）在一个类的静态成员中去访问其非静态成员之所以会出错是因为在类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会出错

 

抽象类遵循的原则：
（1）abstract关键字只能修饰类和方法，不能修饰字段。

（2）抽象类不能被实例化（无法使用new关键字创建对象实例），只能被继承。

（3）抽象类可以包含属性，方法，构造方法，初始化块，内部类，枚举类，和普通类一样，普通方法一定要实现，变量可以初始化、不初始化但不能初始化后在抽象类中重新赋值或操作该变量（只能在子类中改变该变量）。

（4）抽象类中的抽象方法（加了abstract关键字的方法）不能实现。

（5）含有抽象方法的类必须定义成抽象类。

扩展：抽象类和接口的区别：

（1）接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的。

（2）abstractclass 在Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface，实现多重继承。接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。

（3）在abstractclass 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法默认都是 public abstract 类型的。

（4）abstractclass和interface所反映出的设计理念不同。其实abstractclass表示的是"is-a"关系，interface表示的是"has-a"关系。

（5）实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。抽象类中可以有非抽象方法。接口中则不能有实现方法。

（6）接口中定义的变量默认是publicstatic final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。抽象类中的变量默认是friendly 型，其值可以在子类中重新定义，也可以在子类中重新赋值。
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
1、基本语法

这包括static、final、transient等关键字的作用，foreach循环的原理等等。今天面试我问你static关键字有哪些作 用，如果你答出static修饰变量、修饰方法我会认为你合格，答出静态块，我会认为你不错，答出静态内部类我会认为你很好，答出静态导包我会对你很满 意，因为能看出你非常热衷研究技术。

最深入的一次，我记得面试官直接问到了我Volatile关 键字的底层实现原理（顺便插一句，面试和被面试本身就是相对的，面试官能问这个问题同时也让面试者感觉到面试官也是一个喜爱研究技术的人，增加了面试者对 公司的好感，我最终选择的就是问了这个问题的公司），不要觉得这太吹毛求疵了—-越简单的问题越能看出一个人的水平，别人对你技术的考量绝大多数都是以深度优先、广度次之为标准的，切记。

2、集合

非常重要，也是必问的内容。基本上就是List、Map、Set，问的是各种实现类的底层实现原理，实现类的优缺点。

集合要掌握的是ArrayList、LinkedList、Hashtable、HashMap、ConcurrentHashMap、 HashSet的实现原理，能流利作答，当然能掌握CopyOnWrite容器和Queue是再好不过的了。另外多说一 句，ConcurrentHashMap的问题在面试中问得特别多，大概是因为这个类可以衍生出非常多的问题，关于ConcurrentHashMap， 我给网友朋友们提供三点回答或者是研究方向：

（1）ConcurrentHashMap的锁分段技术。

（2）ConcurrentHashMap的读是否要加锁，为什么。

（3）ConcurrentHashMap的迭代器是强一致性的迭代器还是弱一致性的迭代器。

3、设计模式

本来以为蛮重要的一块内容，结果只在阿里巴巴B2B事业部面试的时候被问了一次，当时问的是装饰器模式。

当然咱们不能这么功利，为了面试而学习，设计模式在工作中还是非常重要、非常有用的，23种设计模式中重点研究常用的十来种就可以了，面试中关于设计模式的问答主要是三个方向：

（1）你的项目中用到了哪些设计模式，如何使用。

（2）知道常用设计模式的优缺点。

（3）能画出常用设计模式的UML图。

4、多线程

这也是必问的一块了。因为三年工作经验，所以基本上不会再问你怎么实现多线程了，会问得深入一些比如说Thread和Runnable的区别和联 系、多次start一个线程会怎么样、线程有哪些状态。当然这只是最基本的，出乎意料地，几次面试几乎都被同时问到了一个问题，问法不尽相同。

总结起来是 这么一个意思：

假如有Thread1、Thread2、ThreaD3、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？

聪明的网友们对这个问题是否有答案呢？不难，java.util.concurrent下就有现成的类可以使用。

另外，线程池也是比较常问的一块，常用的线程池有几种？这几种线程池之间有什么区别和联系？线程池的实现原理是怎么样的？实际一些的，会给你一些具体的场景，让你回答这种场景该使用什么样的线程池比较合适。

最后，虽然这次面试问得不多，但是多线程同步、锁这块也是重点。synchronized和ReentrantLock的区别、 synchronized锁普通方法和锁静态方法、死锁的原理及排查方法等等。

5、JDK源码

要想拿高工资，JDK源码不可不读。上面的内容可能还和具体场景联系起来，JDK源码就是实打实地看你平时是不是爱钻研了。我面试过程中被问了不 少JDK源码的问题，其中最刁钻的一个问了我，String的hashCode()方法是怎么实现的，幸好我平时String源代码看得多，答了个大 概。

JDK源码其实没什么好总结的，纯粹看个人，总结一下比较重要的源码：

（1）List、Map、Set实现类的源代码

（2）ReentrantLock、AQS的源代码

（3）AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的

（4）线程池的实现原理

（5）Object类中的方法以及每个方法的作用

这些其实要求蛮高的，我去年一整年基本把JDK中重要类的源代码研究了个遍，真的花费时间、花费精力，当然回头看，是值得的—-不仅仅是为了应付面试。

6、框架

老生常谈，面试必问的东西。一般来说会问你一下你们项目中使用的框架，然后给你一些场景问你用框架怎么做，比如我想要在Spring初始化bean 的时候做一些事情该怎么做、想要在bean销毁的时候做一些事情该怎么做、MyBatis中$和#的区别等等，这些都比较实际了，平时积累得好、有多学习 框架的使用细节自然都不成问题。

如果上面你的问题答得好，面试官往往会深入地问一些框架的实现原理。问得最多的就是Spring AOP的实现原理，当然这个很简单啦，两句话就搞定的的事儿，即使你不会准备一下就好了。我遇到的最变态的是让我画一下Spring的Bean工厂实 现的UML图，当然面对这样一个有深度的问题，我是绝对答不出来的/(ㄒoㄒ)/~~

7、数据库

数据库十有八九也都会问到。一些基本的像union和union all的区别、left join、几种索引及其区别就不谈了，比较重要的就是数据库性能的优化，如果对于数据库的性能优化一窍不通，那么有时间，还是建议你在面试前花一两天专门 把SQL基础和SQL优化的内容准备一下。

不过数据库倒是不用担心，一家公司往往有很多部门，如果你对数据库不熟悉而基本技术又非常好，九成都是会要你的，估计会先把你放到对数据库使用不是要求非常高的部门锻炼一下。

8、数据结构和算法分析

数据结构和算法分析，对于一名程序员来说，会比不会好而且在工作中绝对能派上用场。数组、链表是基础，栈和队列深入一些但也不难，树挺重要的，比较 重要的树AVL树、红黑树，可以不了解它们的具体实现，但是要知道什么是二叉查找树、什么是平衡树，AVL树和红黑树的区别。记得某次面试，某个面试官和 我聊到了数据库的索引，他问我：你知道索引使用的是哪种数据结构实现吗？

我答到用的Hash表吧，答错。他又问，你知道为什么要使用树吗？我答到因为Hash表可能会出现比较多的冲突，在千万甚至是上亿级别的数据面 前，会大大增加查找的时间复杂度。而树比较稳定，基本保证最多二三十次就能找到想要的数据，对方说不完全对，最后我们还是交流了一下这个问题，我也明白了 为什么要使用树，这里不说，网友朋友们觉得索引为什么要使用树来实现呢？

至于算法分析，不会、不想研究就算了，记得某次面试对方问我，Collections.sort方法使用的是哪种排序方法，额，吐血三升。当然为了 显示我的博学，对算法分析也有一定的研究(⊙﹏⊙)b，我还是硬着头皮说了一句可能是冒泡排序吧。当然答案肯定不是，有兴趣的网友朋友们可以去看一下 Collections.sort方法的源代码，用的是一种叫做TimSort的排序法，也就是增强型的归并排序法。

9、Java虚拟机

出乎我的意料，Java虚拟机应该是很重要的一块内容，结果在这几家公司中被问到的概率几乎为0。要知道，我去年可是花了大量的时间去研究Java虚拟机的，光周志明老师的《深入理解Java虚拟机：JVM高级特性与最佳实践》，我就读了不下五遍。

言归正传，虽然Java虚拟机没问到，但我觉得还是有必要研究的，我就简单地列一个提纲吧，谈谈Java虚拟机中比较重要的内容：

（1）Java虚拟机的内存布局

（2）GC算法及几种垃圾收集器

（3）类加载机制，也就是双亲委派模型

（4）Java内存模型

（5）happens-before规则

（6）volatile关键字使用规则

也许面试无用，但在走向大牛的路上，不可不会。

10、Web方面的一些问题

Java主要面向Web端，因此Web的一些问题也是必问的。

我碰到过问得最多的两个问题是：

谈谈分布式Session的几种实现方式。

常用的四种能答出来自然是让面试官非常满意的。

另外一个常问的问题是：讲一下Session和Cookie的区别和联系以及Session的实现原理。这两个问题之外，web.xml里面的内容是重点，Filter、Servlet、Listener，不说对它们的实现原理一清二楚吧，至少能对它们的使用知根知底。另外，一些细节的方面比如get/post的区别、forward/重定向的区别、HTTPS的实现原理也都可能会被考察到。

最后，如果有兴趣有时间，建议学习、研究一下SOA和RPC，面向服务体系，大型分布式架构必备，救命良方、包治百病、屡试不爽。


override、overwrite、overload
http三次握手和四次挥手
osi七层协议
tcp/ip
http协议
String考点
mybatis考点
springmvc考点
什么是Spring IOC 容器？
Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。 
IOC的优点是什么，最小的代价和最小的侵入性使松散耦合得以实现。
什么是Spring的依赖注入？
依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。
面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。

面试总结——Spring框架相关
1. spring IOC与AOP思想的理解

控制反转（IOC）：所谓控制反转就是应用本身不负责依赖对象的创建及维护，依赖对象的创建及维护是由外部容器负责的。这样控制权就由应用转移到了外部容器，控制权的转移就是所谓反转。

依赖注入（DI）：在运行期，由外部容器动态地将依赖对象注入到组件中，从而创建用对象之间协作关系（也称为装配）。在代码中的展现形式是在配置文件applicationContext.xml中管理Bean。

面向切面编程被定义为促使应用程序分离关注点的一项技术。系统由许多不同组件组成，每个组件负责一块特定的功能。除了负责实现自身核心的功能之外，这些组件还承担着额外的职责。诸如日志、事务管理和安全此类的系统服务经常融入到有自身核心业务逻辑的组件中去，这些系统通常被称为横切关注点，因为它们总是跨越系统的多个组件。

**依赖注入让相互协作的软件组织保持松散耦合； 
AOP编程把遍布应用各处的功能分离出来形成可重用的组件。**

2. spring aop中的propagation的7种配置的意思 
REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 
SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。 
MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。 
REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。 
NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 
NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 
NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。

3. SpringMVC与Struts2区别与比较总结 
（1）Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应。所以说从架构本身上SpringMVC就容易实现restful url,而struts2的架构实现起来要费劲，因为Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。 
（2）由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量。而Struts2虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。 
（3）由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。 
（4）拦截器实现机制上，Struts2有以自己的interceptor机制，SpringMVC用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。 
（5）SpringMVC的入口是servlet，而Struts2是filter（filter和servlet是不同的，以前认为filter是servlet的一种特殊）。 
（6）SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。 
（7）SpringMVC验证支持JSR303，处理起来相对更加灵活方便，而Struts2验证比较繁琐，感觉太烦乱。 
（8）Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。 
（9）设计思想上，Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。 
（10）SpringMVC开发效率和性能高于Struts2。 
（11）SpringMVC可以认为已经100%零配置。

4. Spring中bean的生命周期

创建：<bean name=”” class=”” 额外属性> 
初始化：配置init-method/实现接口InitializingBean 
调用：context.getBean(),进行方法的调用 
销毁：配置destroy-method/实现DisposableBean接口

5. Spring注入方式 
接口注入 
属性注入（属性的SET/GET） 
构造注入（构造方法注入） 
使用构造函数依赖注入时，Spring保证所有一个对象所有依赖的对象先实例化后，才实例化这个对象。使用set方法依赖注入时，Spring首先实例化对象，然后才实例化所有依赖的对象。 
当设值注入与构造注入同时存在时，先执行设值注入，再执行构造注入。

14.springMVC的流程？

答：1.用户发送请求至前端控制器DispatcherServlet

2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。

3.处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。

4.DispatcherServlet通过HandlerAdapter处理器适配器调用处理器

5.执行处理器(Controller，也叫后端控制器)。

6.Controller执行完成返回ModelAndView

7.HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet

8.DispatcherServlet将ModelAndView传给ViewReslover视图解析器

9.ViewReslover解析后返回具体View

10.DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。

11.DispatcherServlet响应用户

数据库考点
1、触发器的作用？
触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。
2、什么是存储过程？用什么来调用？
存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 调用： 1）可以用一个命令对象来调用存储过程。 2）可以供外部程序调用，比如：java程序。
3、存储过程的优缺点？
优点： 1）存储过程是预编译过的，执行效率高。 2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。 3）安全性高，执行存储过程需要有一定权限的用户。 4）存储过程可以重复使用，可减少数据库开发人员的工作量。 缺点：移植性差
4、存储过程与函数的区别
存储过程	函数
用于在数据库中完成特定的操作或者任务（如插入、删除等）	用于特定的数据（如选择）
程序头部声明用procedure	程序头部声明用function
程序头部声明时不需描述返回类型	程序头部声明时要描述返回类型，而且PL/SQL块中至少要包括一个有效的return语句
可以使用in/out/in out 三种模式的参数	可以使用in/out/in out 三种模式的参数
可作为一个独立的PL/SQL语句来执行	不能独立执行，必须作为表达式的一部分调用
可以通过out/in out 返回零个或多个值	通过return语句返回一个值，且改值要与声明部分一致，也可以是通过out类型的参数带出的变量
SQL语句(DML 或SELECT)中不可调用存储过程	SQL语句(DML 或SELECT)中可以调用函数
5、索引的作用？和它的优点缺点是什么？
索引就一种特殊的查询表，数据库的搜索可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。
6、什么样的字段适合建索引
唯一、不为空、经常被查询的字段
7、索引类型有哪些？
逻辑上：
Single column 单行索引
Concatenated 多行索引
Unique 唯一索引
NonUnique 非唯一索引
Function-based 函数索引
Domain 域索引 物理上：
Partitioned 分区索引
NonPartitioned 非分区索引
B-tree ：
Normal 正常型B树
Rever Key 反转型B树 Bitmap 位图索引
8、什么是事务？什么是锁？
事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。 锁：在所以的DBMS中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。当然锁还分级别的。
9、什么叫视图？游标是什么？
视图：是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。 游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。
10、视图的优缺点
优点： 1）对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。 2 ）用户通过简单的查询可以从复杂查询中得到结果。 3 ）维护数据的独立性，试图可从多个表检索数据。 4 ）对于相同的数据可产生不同的视图。 缺点： 性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据
11、列举几种表连接方式,有什么区别？
内连接、自连接、外连接（左、右、全）、交叉连接 内连接：只有两个元素表相匹配的才能在结果集中显示。 外连接： 左外连接:左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 右外连接:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 全外连接：连接的表中不匹配的数据全部会显示出来。 交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。
12、主键和外键的区别？
主键在本表中是唯一的、不可唯空的，外键可以重复可以唯空；外键和另一张表的主键关联，不能创建对应表中不存在的外键。
13、在数据库中查询语句速度很慢，如何优化？
1.建索引 2.减少表之间的关联 3.优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据 量大的表排在前面 4.简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据 5.尽量用PreparedStatement来查询，不要用Statement
14、数据库三范式是什么?
第一范式：列不可再分 第二范式：行可以唯一区分，主键约束 第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束 且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上
15、union和union all有什么不同?
UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION。 UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。 从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL。
16、Varchar2和varchar有什么区别？
Char的长度是固定的，而varchar2的长度是可以变化的，比如，存储字符串“abc”对于char(20)，表示你存储的字符将占20个字节，包含17个空，而同样的varchar2（20）只占了3个字节，20只是最大值，当你存储的字符小于20时，按实际长度存储。 char的效率要被varchar2的效率高。 目前varchar是varchar2的同义词，工业标准的varchar类型可以存储空字符串，但是oracle不能这样做，尽管它保留以后这样做的权利。Oracle自己开发了一个数据类型varchar2,这个类型不是一个标准的varchar，他将在数据库中varchar列可以存储空字符串的特性改为存储null值，如果你想有向后兼容的能力，oracle建议使用varchar2而不是varchar
17、Oracle和Mysql的区别？
1）库函数不同。 2）Oracle是用表空间来管理的，Mysql不是。 3）显示当前所有的表、用户、改变连接用户、显示当前连接用户、执行外部脚本的语句的不同。 4）分页查询时候时候，mysql用limit oracle用rownum
mysql> SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 //为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： mysql> SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. //如果只给定一个参数，它表示返回最大的记录行数目： mysql> SELECT * FROM table LIMIT 5; //检索前 5 个记录行 //换句话说，LIMIT n 等价于 LIMIT 0,n。 5）sql的语法的不同。

18、Oracle语句有多少类型
Oracle语句分三类：DDL、DML、DCL。 DDL（Data Definition Language）数据定义语言，包括： Create语句：可以创建数据库和数据库的一些对象。 Drop语句：可以删除数据表、索引、触发程序、条件约束以及数据表的权限等。 Alter语句：修改数据表定义及属性。 Truncate语句：删除表中的所有记录,包括所有空间分配的记录被删除。 DML（Data Manipulation Language）数据操控语言，包括： Insert语句：向数据表张插入一条记录。 Delete语句：删除数据表中的一条或多条记录，也可以删除数据表中的所有记录，但是它的操作对象仍是记录。 Update语句：用于修改已存在表中的记录的内容。 DCL（Data Control Language）数据库控制语言，包括： Grant语句：允许对象的创建者给某用户或某组或所有用户（PUBLIC）某些特定的权限。 Revoke语句：可以废除某用户或某组或所有用户访问权限
19、oracle分页查询语句
使用rownum，两种如下： 第一种： select * from (select t.*,rownum row_num from mytable t) b where b.row_num between 1 and 10 第二种： select * from ( select a.*, rownum rn from mytable a where rownum <= 10 ) where rn >= 1 使用rowid， 如下： select * from scott.emp where rowid in (select rd from (select rowid as rd ,rownum as rn from scott.emp ) where rn<=6 and rn>3)
20、从数据库中随机取50条
select * from (select * from t_example order by dbms_random.random) where rownum <= 50
21、order by与group by的区别
order by 排序查询、asc升序、desc降序 group by 分组查询、having 只能用于group by子句、作用于组内，having条件子句可以直接跟函数表达式。使用group by 子句的查询语句需要使用聚合函数。
22、commit在哪里会运用
oracle的commit就是DML语句提交数据（这里是释放锁不是锁表），在未提交前你前面的操作更新的都是内存，没有更新到物理文件中。 执行commit从用户角度讲就是更新到物理文件了，事实上commit时还没有写date file，而是记录了redo log file，要从内存写到data物理文件，需要触发检查点，由DBWR这个后台进程来写，这里内容有点多的，如果不深究的话你就理解成commit即为从内存更新到物理文件。
23、行转列、列换行怎么转
1）使用decode函数 2）使用case when语句
24、什么是PL/SQL？
PL/SQL是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）。PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点，所以PL/SQL把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算。PL/SQL 只有 Oracle 数据库有。 MySQL 目前不支持 PL/SQL 的。
25、序列的作用
Oracle使用序列来生成唯一编号，用来处理一个表中自增字段。 Oracle序列是原子对象，并且是一致的。也就是说，一旦您访问一个序列号，Oracle将在处理下一个请求之前自动递增下一个编号，从而确保不会出现重复值。
26、表和视图的关系
视图其实就是一条查询sql语句，用于显示一个或多个表或其他视图中的相关数据。 表就是关系数据库中实际存储数据用的。
27、oracle基本数据类型
1）字符串类型 char、nchar、varchar、varchar2、nvarchar2 2）数字类型 number、integer 3）浮点类型 binary_float、binary_double、float 4）日期类型 date、 timestamp 5）LOB类型 blob、clob、nclob、bfile
28、truncate与 delete区别
TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。 DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。
TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 TRUNCATE,DELETE,DROP 放在一起比较：
TRUNCATE TABLE ：删除内容、释放空间但不删除定义。
DELETE TABLE: 删除内容不删除定义，不释放空间。
DROP TABLE ：删除内容和定义，释放空间。
29、oracle获取系统时间
select to_char(sysdate, 'yyyy-MM-dd HH24:mi:ss') from dual;
30、oracle怎么去除去重
使用distinct关键字
31、现在有表:
A(id ,name,regdate) B(id,groupid) C(id,name2) 写出下面的SQL语句 A)统计A表中每个月注册用户数 select count(*),to_char(regdate,'yyyymm') from A group by to_char(regdate,'yyyymm'); B)统计A表中有姓名相同的用户数 select count(*) from (select name from A group by name having count(*) >1); C)如果表A中有姓名相同的用户,把相同的查出,写入表C中 nsert into C(name2) select name from A group by name having count(*) >1; D)A中ID有多个相同的数据,A中姓名相同的ID只保留注册时间最大的数据 delete from E where e.regdate < (select max(regdate) from a X where E.id = X.id);
32、现有表：
Student(S#,SN,SD)学生表 Course(C#,CN,T#)课程表 SC（S#,C#,score）成绩表 1.查询选了课程‘税收’的学生的学号和名字 答： select SN,SD from Student where S# in( select S# from Course C , SC where C.C#=SC.C# and CN= ’税收基础’); 2.查询选课数量大于5的学生的学号和名字 答： select SN,SD from Student where S# in ( select S# from SC group by S# having count(distinct C#) > 5); ) 3.建立一个学生表students，包括name,age,head_teacher,id,score(姓名，年龄，班主任，学号，成绩) Create table students ( Id number(9) not null primary key, Name varchar2(40) not null, Age int check(age between 0 and 100), Head_teacher vachar2(40), Score float ); 4.对上表插入一条记录，姓名：张三，年龄：18，班主任：李四，学号：22 Insert into student(id,name,age,head_teacher) values(‘22’,’张三’,’18’,’李四’)； 5.对上表中的age+name创建一个索引，并说明它的作用和使用方法 Create index student_index on students(age,name);
33、怎样把这样一个表（表名：tmp_table_201307）
year month amount 2012 1 1.1 2012 2 1.2 2012 3 1.3 2012 4 1.4 2012 4 1.6 2013 1 2.1 2013 2 2.2 2013 2 2.2 2013 3 2.3 　2013 4 2.4 　　查成这样一个结果 　　year m1 m2 m3 m4 　　2012 1.1 1.2 1.3 3 　　2013 2.1 4.4 2.3 2.4 　　Select 　　year, 　　Sum(case when month = 1 then amount else 0 end) as m1, 　　Sum(case when month = 2 then amount else 0 end) as m2, 　　Sum(case when month = 3 then amount else 0 end) as m3, 　　Sum(case when month = 4 then amount else 0 end) as m4 　　From tmp_table_201307 a 　　Group by year 　　Order by 1;
34、数据库中有一张表ismg_icp_flow，结构如下
SQL> desc ismg_icp_flow Name Null Type ———————————————————————————————— ICPNO NOT NULL VARCHAR2(6) SERVICE_ID NOT NULL VARCHAR2(10) STAT_MIN NOT NULL DATETIME MT_RECV_OK NOT NULL NUMBER(10) 请写出一条SQL语句同时满足以下3个条件： 计算MT_RECV_OK的总和（显示为total），并以此对结果集进行升序排序 以ICPNO和SERVICE_ID两个字段进行分组 所得出数据的STAT_MIN必须为大于2003年1月1号0时0分并且小于2003 年2月1号0时0分 期望的输出结果如下： ICPNO SERVICE_ID TOTAL ———— —————— ———————————— 901001 7700 271965 901001 7800 3857795 答： select ICPNO,SERVICE_ID,sum(MT_RECV_OK) TOTAL from ismg_icp_flow where STAT_MIN between to_date('2003-1-1','yyyy-mm-dd') and to_date('2003-2-1','yyyy-mm-dd') group by ICPNO,SERVICE_ID order by TOTAL;
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1.存储过程是什么？
我们常用的关系型数据库是MySQL，操作数据库的语言一般为SQL语句，SQL在执行的时候需要要先编译，然后执行，而存储过程（Stored Procedure）是一组为了完成某种特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。

一个存储过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对面向对象方法的模拟，它允许控制数据的访问方式。

优点
(1)存储过程增强了SQL语言的功能和灵活性：存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。 
(2)存储过程允许标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且可以随时对存储过程进行修改，对应用程序源代码毫无影响。 
(3)存储过程能实现较快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。 
(4)存储过程能减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织成存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。 
(5)存储过程可被作为一种安全机制来充分利用：系统管理员通过执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。

2.索引
是什么？
索引（Index）是帮助MySQL高效获取数据的数据结构；在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，可以在这些数据结构上实现高级查找算法，提高查询速度，这种数据结构，就是索引。

索引存储分类
索引是在MySQL的存储引擎层中实现的，而不是在服务层实现的。所以各种存储引擎支持的索引并不相同，MySQL目前提供了以下4种索引。

B-Tree 索引：最常见的索引类型，大部分引擎都支持B树索引。 
HASH 索引：只有Memory引擎支持，使用场景简单。 
R-Tree 索引(空间索引)：空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型。 
Full-text (全文索引)：全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MySQL5.6版本提供对全文索引的支持。

B-TREE索引类型
普通索引 
这是最基本的索引类型，而且它没有唯一性之类的限制，可以通过以下几种方式创建： 
（1）创建索引: CREATE INDEX 索引名 ON 表名(列名1，列名2,…); 
（2）修改表: ALTER TABLE 表名 ADD INDEX 索引名 (列名1，列名2,…); 
（3）创建表时指定索引：CREATE TABLE 表名 ( […], INDEX 索引名 (列名1，列名 2,…) ); 
UNIQUE索引 
表示唯一的，不允许重复的索引，若某一字段的信息不能重复（例如身份证号），可以将该字段的索引设置为unique： 
（1）创建索引：CREATE UNIQUE INDEX 索引名 ON 表名(列名1，列名2,…); 
（2）修改表：ALTER TABLE 表名ADD UNIQUE 索引名 (列名1，列名2,…); 
（3）创建表时指定索引：CREATE TABLE 表名( […], UNIQUE 索引名 (列名1，列名2,…)); 
主键：PRIMARY KEY索引 
主键是一种唯一性索引，但它必须指定为“PRIMARY KEY”。可以将其理解为 索引名固定为 PRIMARY KEY 的 UNIQUE索引。 
（1）主键一般在创建表的时候指定：“CREATE TABLE 表名( […], PRIMARY KEY (列的列表) ); ”。 
（2）但是，我们也可以通过修改表的方式加入主键：“ALTER TABLE 表名 ADD PRIMARY KEY (列的列表); ”。 
每个表只能有一个主键。 （主键相当于聚合索引，是查找最快的索引） 
注：不能用CREATE INDEX语句创建PRIMARY KEY索引

常用语法
设置索引 
在执行CREATE TABLE语句时可以创建索引，也可以单独用CREATE INDEX或ALTER TABLE来为数据表增加索引。

1．ALTER TABLE - ALTER TABLE可以用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。

ALTER TABLE table_name ADD INDEX index_name (column_list)

ALTER TABLE table_name ADD UNIQUE index_name (column_list)

ALTER TABLE table_name ADD PRIMARY KEY (column_list)
1
2
3
4
5
2．CREATE INDEX - CREATE INDEX可对表增加普通索引或UNIQUE索引。

CREATE INDEX index_name ON table_name (column_list)

CREATE UNIQUE INDEX index_name ON table_name (column_list)
1
2
3
删除索引 
可利用ALTER TABLE或DROP INDEX语句来删除索引。类似于CREATE INDEX语句，DROP INDEX可以在ALTER TABLE内部作为一条语句处理，语法如下。

DROP INDEX index_name ON talbe_name

ALTER TABLE table_name DROP INDEX index_name

ALTER TABLE table_name DROP PRIMARY KEY
1
2
3
4
5
其中，前两条语句是等价的，删除掉table_name中名为index_name的索引。 
第3条语句只在删除PRIMARY KEY索引时使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。

如果从表中删除了某列，则索引会受到影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。

查看索引

mysql> show index from tblname;
1
设置索引的原则
较频繁的作为查询条件的字段应该创建索引
唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
更新非常频繁的字段不适合创建索引
不会出现在 WHERE 子句中的字段不该创建索引
索引的选择性较低不宜建索引 
注：所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数的比值，显然选择性的取值范围为(0, 1]：
SELECT count(DISTINCT(column_name))/count(*) AS Selectivity FROM table_name;
1
索引的弊端
索引是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。

参考1

3.B+ 树
这里写图片描述 
如上图，是一颗b+树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

b+树的查找过程
如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

b+树性质
1.通过上面的分析，我们知道IO次数取决于b+树的高度h，假设当前数据表的数据量为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。 
2.当b+树的数据项是复合的数据结构的时候，比如(name,age,sex)，b+树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

参考2

4.事务
是什么？
事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，由一条或者多条sql语句组成，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。

ACID特性
事务应该具有4个属性：原子性、一致性、隔离性、持久性。

原子性（Atomicity）：指整个数据库事务是不可分割的工作单位。只有事务中所有的数据库操作都执行成功，整个事务的执行才算成功。事务中任何一个sql语句执行失败，那么已经执行成功的sql语句也必须撤销，数据库状态应该退回到执行事务前的状态。 
一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束，也就是说在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏 
隔离性（Isolation）：隔离性也叫做并发控制、可串行化或者锁。事务的隔离性要求每个读写事务的对象与其它事务的操作对象能相互分离，即该事务提交前对其它事务都不可见，这通常使用锁来实现多个事务并发执行时，一个事务的执行不应影响其他事务的执行。 
持久性（Durability）：表示事务一旦提交了，其结果就是永久性的，也就是数据就已经写入到数据库了，如果发生了宕机等事故，数据库也能将数据恢复。

事务的分类
事务分为一下5类：

扁平事务；
带有保存点的扁平事务；
链事务；
嵌套事务；
分布式事务。
扁平事务 
扁平事务是最简单的一种，也是实际开发中使用的最多的一种事务。在这种事务中，所有操作都处于同一层次，最常见的方式如下：

 BEGIN WORK
     Operation 1
     Operation 2
     Operation 3
     ...
     Operation N
 COMMIT WORK
1
2
3
4
5
6
7
或者：

BEGIN WORK
     Operation 1
     Operation 2
     Operation 3
     ...
     Operation N
     (Error Occured)
 ROLLBACK WORK
1
2
3
4
5
6
7
8
9
扁平事务很简单，但有一个主要缺点是不能提交或回滚事务的某一部分，或者分几个独立的步骤去提交。 
比如有这样的一个例子，我从呼和浩特去深圳，为了便宜，我可能这么干：

 BEGIN WORK
     Operation1:呼和浩特---火车--->北京
     Operation2:北京---飞机--->深圳
 ROLLBACK WORK
1
2
3
4
但是，如果在Operation1中，从呼和浩特到北京的火车晚点了，错过了航班，怎么办？ 
因为扁平事务的特性，那我就需要回滚，我需要再回到呼和浩特，这样做的成本太高，所以就有了下面的第二种事务——带有保存点的扁平事务。

带有保存点的扁平事务 
这种事务除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。

链事务 
链事务，就是指回滚时，只能恢复到最近一个保存点；而带有保存点的扁平事务则可以回滚到任意正确的保存点。

嵌套事务

通过下面实例来说明什么叫嵌套事务

BEGIN WORK
     SubTransaction1:
             BEGIN WORK
                 SubOperationX
             COMMIT WORK
     SubTransaction2:
             BEGIN WORK
                 SubOperationY
             COMMIT WORK
     ...
     SubTransactionN:
             BEGIN WORK
                 SubOperationN
             COMMIT WORK
 COMMIT WORK
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
这就是嵌套事务，在事务中再嵌套事务，位于根节点的事务称为顶层事务。事务的前驱称为父事务，事务的下一层称为子事务。

子事务既可以提交也可以回滚，但是它的提交操作并不马上生效，除非由其父事务提交。因此就可以确定，任何子事务都在顶层事务提交后才真正的被提交了。同理，任意一个事务的回滚都会引起它的所有子事务一同回滚。

分布式事务 
分布式事务通常是指在一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点，比如：通过建设银行向招商银行转账，建设银行和招商银行肯定用的不是同一个数据库，同时二者的数据库也不在一个网络节点上，那么当用户跨行转账，就是通过分布式事务来保证数据的ACID的。

在MySQL中使用事务
在MySQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行COMMIT操作。因此要显示地开启一个事务须使用命令BEGIN或START TRANSACTION，或者执行命令SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。

来看看我们可以使用哪些事务控制语句。

BEGIN或START TRANSACTION；显示地开启一个事务；
COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；
ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；
RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；
ROLLBACK TO identifier；把事务回滚到标记点；
SET TRANSACTION；用来设置事务的隔离级别。
事务的隔离级别
在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。 
InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。这些隔离级别之间的区别如下： 
这里写图片描述

脏读：一个事务读取到了另外一个事务没有提交的数据； 
比如：事务T1更新了一行记录的内容，但是并没有提交所做的修改。事务T2读取到了T1更新后的行，然后T1执行回滚操作，取消了刚才所做的修改。现在T2所读取的行就无效了； 
不可重复读：在同一事务中，两次读取同一数据，得到内容不同； 
比如：事务T1读取一行记录，紧接着事务T2修改了T1刚才读取的那一行记录。然后T1又再次读取这行记录，发现与刚才读取的结果不同。这就称为“不可重复”读，因为T1原来读取的那行记录已经发生了变化； 
幻读：同一事务中，用同样的操作读取两次，得到的记录数不相同； 
比如：事务T1读取一条指定的WHERE子句所返回的结果集。然后事务T2新插入 一行记录，这行记录恰好可以满足T1所使用的查询条件中的WHERE子句的条件。然后T1又使用相同的查询再次对表进行检索，但是此时却看到了事务T2刚才插入的新行。这个新行就称为“幻像”，因为对T1来说这一行就像突然出现的一样。 
隔离级别越低，事务请求的锁越少或保持锁的时间就越短。InnoDB存储引擎默认的支持隔离级别是REPEATABLE READ；在这种默认的事务隔离级别下已经能完全保证事务的隔离性要求，即达到SQL标准的SERIALIZABLE级别隔离。

我们可以可以用SET TRANSACTION语句改变单个会话或者所有新进连接的隔离级别。它的语法如下：

5.视图
视图是一种虚拟的表，具有和物理表相同的功能，可以对视图进行增，改，查操作，视图通常是有一个表或者多个表的行或列的子集，对视图的修改不影响基本表，它使得我们获取数据更容易，相比多表查询。

6.超键 候选键 主键 外键
超键：在关系中能唯一标识元组(数据库中的一条记录)的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 
候选键：是最小超键，即没有冗余元素的超键。 
主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合，用户选作元组标识的一个侯选键称为主键。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 
外键：在一个表中存在的另一个表的主键称此表的外键，外键主要是用来描述两个表的关系。

7.三个范式
第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。

第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。 
第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y。

8.E-R图
是什么？
E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。

E-R方法是“实体-联系方法”（Entity-Relationship Approach）的简称。它是描述现实世界概念结构模型的有效方法，是表示概念模型的一种方式，用矩形表示实体型，矩形框内写明实体名；用椭圆表示实体的属性，并用无向边将其与相应的实体型连接起来；用菱形表示实体型之间的联系，在菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1:1,1:n或m:n）。

构成
在ER图中有如下四个成分： 
矩形框：表示实体，在框中记入实体名。 
菱形框：表示联系，在框中记入联系名。 
椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。 
连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)

实体型(Entity)：具有相同属性的实体具有相同的特征和性质，用实体名及其属性名集合来抽象和刻画同类实体;在E-R图中用矩形表示，矩形框内写明实体名；比如学生张三丰、学生李寻欢都是实体。如果是弱实体的话，在矩形外面再套实线矩形。 
属性(Attribute)：实体所具有的某一特性，一个实体可由若干个属性来刻画。在E-R图中用椭圆形表示，并用无向边将其与相应的实体连接起来；比如学生的姓名、学号、性别、都是属性。如果是多值属性的话，在椭圆形外面再套实线椭圆，如果是派生属性则用虚线椭圆表示。 
联系(Relationship)：联系也称关系，信息世界中反映实体内部或实体之间的联系。实体内部的联系通常是指组成实体的各属性之间的联系；实体之间的联系通常是指不同实体集之间的联系。在E-R图中用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1 : 1，1 : n或m : n），比如老师给学生授课存在授课关系，学生选课存在选课关系。如果是弱实体的联系则在菱形外面再套菱形。

联系可分为以下 3 种类型： 
(1) 一对一联系(1 ∶1) 
例如，一个班级有一个班长，而每个班长只在一个班级任职，则班级与班长的联系是一对一的。 
(2) 一对多联系(1 ∶N) 
例如，某校教师与课程之间存在一对多的联系“教”，即每位教师可以教多门课程，但是每门课程只能由一位教师来教。 
(3) 多对多联系(M ∶N) 
例如，学生与课程间的联系(“学 ”)是多对多的，即一个学生可以学多门课程，而每门课程可以有多个学生来学。联系也可能有属性。例如，学生“ 学” 某门课程所取得的成绩，既不是学生的属性也不是课程的属性。由于“ 成绩” 既依赖于某名特定的学生又依赖于某门特定的课程，所以它是学生与课程之间的联系“ 学”的属性。

作图步骤
⑴确定所有的实体集合 
⑵选择实体集应包含的属性 
⑶确定实体集之间的联系 
⑷确定实体集的关键字，用下划线在属性上表明关键字的属性组合 
⑸确定联系的类型，在用线将表示联系的菱形框联系到实体集时，在线旁注明联系的类型。

实例： 
ER图实例

参考3

参考4

9.处理重复记录的常用操作
(1)查找表中多余的重复记录，重复记录是根据单个字段(column_name)来判断。

select * from table_name where column_name in (select column_name from table_name group by column_name having count(column_name) > 1)
1
(2)删除表中多余的重复记录，重复记录是根据单个字段(column_name)来判断，只留有id最小的记录。

delete from table_name where column_name in (select b.column_name from (select column_name from table_name group by column_name having count(column_name)>1)b);
1
(3)查找表中多余的重复记录（多个字段）。

select * from table_name a where (a.column_name1,a.column_name2) in (select column_name1,column_name2 from vitae group by column_name1,column_name2 having count(*) > 1)
1
(4)删除表中多余的重复记录（多个字段），只留有rowid最小的记录 。

delete from table_name a where (a.column_name1,a.column_name2) in (select column_name1,column_name2 from table_name group by column_name1,column_name2 having count(*) > 1) and rowid not in (select min(rowid) from table_name group by column_name1,column_name2 having count(rowid)>1)
1
10.批处理
MySQL 支持以批处理的方式执行一批SQL语句，例如：

create table test(id int,name varchar(20));
insert into test values(1,'watson');
1
2
batchfile.txt里包含下面的一些SQL 语句，此文件在linux系统中的路径/home/wming/batchfile.txt：

insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
insert into test select * from test;
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
执行上面的文件，test 表在 MyZone 数据库中：

mysql -uroot -p -D MyZone < /home/wming/batchfile.txt
1
上面的例子通过批处理执行插入语句，下面的例子是通过批处理执行查询语句：

此时的batchfile2.txt里含有query的信息：

select * from test limit 200;
insert into test select * from test;
insert into test select * from test;
1
2
3
下面的mysql0716.out就记录了 select * from test limit 200 查询语句的结果集。

mysql -uroot -p -D MyZone < /home/wming/batchfile2.txt >/home/wming/mysql0716.out
1
11.MyISAM与InnoDB的区别是什么？
1、存储结构
MyISAM：每个MyISAM表在磁盘上存储成三个文件，文件的名字以表的名字开始，扩展名指出文件类型：.frm文件存储表定义；数据文件的扩展名为.MYD (MYData)；索引文件的扩展名是.MYI (MYIndex)。 
InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。

2、存储空间
MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。 
InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。

3、可移植性、备份及恢复
MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。 
InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。

4、事务支持
MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。 
InnoDB：支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。

这一点是非常重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。

5、AUTO_INCREMENT
MyISAM:可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。 
InnoDB: InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。

6、表锁差异
MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。 
InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的性能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。

7、 全文索引
MyISAM：支持 FULLTEXT类型的全文索引。 
InnoDB：不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。

8、表主键
MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。 
InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。

9、 表的具体行数
MyISAM：保存有表的总行数，如果select count() from table;会直接取出出该值。 
InnoDB：没有保存表的总行数，如果使用select count() from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。

10、CURD操作
MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。 
InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。

11、 外键
MyISAM：不支持 
InnoDB：支持 
通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体视情况而定。 
参考

12. 乐观锁 与 悲观锁
数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和一致性以及数据库的统一性。

乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制采用的主要技术手段。

无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。

针对不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为仅在DBMS中存在的概念，更不要把他们和数据库中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。

悲观锁
在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作在某行数据上应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。

悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

悲观锁：正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

悲观锁的流程： 
1.在对某一记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 
2.如果加锁失败，说明该记录正在被修改，那么当前操作可能要等待或者抛出异常， 具体响应方式由开发者根据实际情况决定。 
3.如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。 
4.其间如果有其他事务要对该记录做修改或加排他锁，都会等待该事务将该记录解锁或直接抛出异常。

MySQL InnoDB中使用悲观锁

注意：要使用悲观锁，必须先关闭mysql数据库的自动提交功能，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。

set autocommit=0;
1
//0.开始事务
begin;/begin work;/start transaction; (三者选一就可以)
//1.查询出商品信息
select status from t_goods where id=1 for update;
//2.根据商品信息生成订单
insert into t_orders (id,goods_id) values (null,1);
//3.修改商品status为2
update t_goods set status=2;
//4.提交事务
commit;/commit work;
1
2
3
4
5
6
7
8
9
10
上面的查询语句中，我们使用了select…for update的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它事务必须等本次事务提交之后才能对该记录进行操作。这样我们可以保证当前的数据不会被其它事务修改。

注意：上面提到，使用select…for update会把数据给锁住，不过我们需要注意一下锁的级别，MySQL InnoDB默认为行级锁。行级锁都是基于索引的，如果一条SQL语句没有用到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。

优点与不足： 
优点：悲观并发控制实际上是采用“先取锁再访问”的保守策略，为数据处理的安全性提供了保证； 
缺点：在效率方面，处理加锁的机制会让数据库产生额外的开销，同时会增加产生死锁的机率；另外，在只读型事务中由于不会产生冲突，也没必要使用锁，这样做只会增加系统负载；还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数

乐观锁
在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理数据时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务对该数据做过修改。如果其他事务更新过该数据的话，正在提交的事务会进行回滚。乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。

乐观锁（ Optimistic Locking ）是相对悲观锁而言，乐观锁假设数据一般情况下不会造成冲突，所以在事务对数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回错误信息，让用户决定如何去做。

相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制，一般用记录数据版本的方式实现乐观锁。

数据版本：为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，便对版本标识进行一次更新。当事务提交更新的时候，需要判断数据库表对应记录的当前版本信息与第一次取出来的版本标识是否一致，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。

实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。

使用版本号实现乐观锁

使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。

1.查询出商品信息
select (status,status,version) from t_goods where id=#{id}
2.根据商品信息生成订单
3.修改商品status为2
update t_goods 
set status=2,version=version+1
where id=#{id} and version=#{version};
1
2
3
4
5
6
7
乐观并发控制假设事务之间的数据竞争(data race)概率比较小，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

13.左 右 连接 全连接 内连接



1.你是非专业的，如何规划学习，平常如何接触计算机行业？在学校有什么突破性的研究成果？
2.为什么想到转计算机这一块，而且花这么多学Java？（回答热爱互联网自由、开放的氛围）
3.谈谈当前互联一些主流应用技术，未来的趋势往哪些发展，谈谈微服务吧？(这个就瞎了)
4.抽象类和接口的区别？（接口方法都是抽象，只能有静态常量；）
5.讲一讲平时用到的抽象类，为什么使用抽象类？（我提到了AbstractStringBuilder以及他的子类StringBuilder和StringBuffer）
6.谈谈Java堆和栈？（巴拉巴拉都说了一遍）
7.什么时候发生Full GC？（老年代空间不够的时候）
8.写代码时候如何避免FullGC对系统的影响？(我回答的是减少对象的创建，多使用单例)
9.多线程如何实现线程安全？（synchronized，lock，volatile只能是轻量级，不能保证线程安全，对于线程不共享的资源使用ThreadLocal）
10.解释一下信号量？（举了一个上厕所的例子）
11.解释一下乐观锁和悲观锁的区别？
12.乐观锁如何实现？乐观锁在什么时候进行加锁？（CAS，资源竞争的时候加锁）
13.线程死锁如何调试？用什么工具来调试定位？（我回答Jconsle）
14.SQL注入是什么，如何避免SQL注入？（回答SQL使用preparestament，应用上面使用正则表达式过滤有危害的sql）
15.MySQL如何实现分页？如何优化limit？（第二点没有答出来。）
16.SQL语句调优有哪些方法？（看慢日志定位SQL语句，使用explain 分析SQL）(面试回答，了解，基本可以)
17.Timestamps和datetime的差异？（我只回答了起始时间不同，没有回答字节不同）(行了，我大概了解)
18.Linux下如何查看文件？在文件中如何搜索关键字？（第一问回答了vi/vim，第二问我回答find+查找内容命令，我的脑子肯定出了问题，回答了搜索文件命令）
19.用什么命令查看端口是否被占用？（我回答用top看线程，然后 ps +grep，应该是没回答出来，Linux确实不太行，平时偶尔用下Ubuntu）
20.了解过Zookeeper嘛？（回答正在看Paxos到Zookeeper这本书）
21.如何实现session共享？（回答做过单点登陆，我使用Redis实现session）（好的呀，我知道了，你这边的情况我了解了，你有什么问我的嘛？）
22.我们我还有哪些方面提高？（这个话题我很难接啊。。。最大的不足可能。。。怎么说呢。实习生普遍经验缺乏一点，不同于社招，社招要求会高很多很多，实习生我觉得你还好吧，我们跟多的主要是要横向比对，所以我们上来不会把你的想法否定掉，你要我提出不足，社招我可以说，但是或者校招实习生还可以吧）



完整面经+总结
Cvte提前批
一面（电话）
自我介绍
介绍你的项目
加密解密了解么？几种算法，讲一下你了解的
多线程了解么？什么是线程安全？
说一个你最熟悉的设计模式
讲一下你项目中用到了哪些设计模式
Java的hashmap的原理
Hashmap的线程安全性，什么是线程安全的？如何实现线程安全
数据库的索引了解么？介绍一下
数据库有哪些优化的方法？讲你自己知道的
为什么事务可以优化数据库？
二面（视频）
自我介绍
介绍项目
Mysql的数据库引擎，区别特点
设计模式了解？讲一下最熟悉的
写一个单例模式，答主写的是双检查锁单例，问了为什么用Volatile，synchronize
单例模式在你项目里哪些应用？
数据连接池采用了什么设计模式？意义是什么？
对高负载有了解么
你意向的技术方向是哪块？（答主回答的高并发，然后面试官说他是做高负载的）
对高并发有了解么？
校招首次面试，二面跪。发现存在以下问题：
（1）准备不充分（自我介绍，项目介绍，项目难点等需提前准备）（2）基础不扎实（面试中问的数据库相关问题基本没答上来）
（3）缺乏亮点（缺乏体现自己能力的东西，比如项目难点如何解决，对一些前沿技术的了解等）
庆幸的当时只是八月初，大部分大厂的校招还没开始，有足够的时间去提高，比如深入复习数据库这一块的内容，深入去研究项目，了解一些前沿的新技术等。

阿里内推
一面（电话）
听说你有博客，博客里大概有什么内容？
项目介绍，最复杂的表
Hashmap的原理
Hashmap为什么大小是2的幂次
介绍一下红黑树
Arraylist的原理
Arraylist的扩容机制
为什么arraylist扩容是1.5倍
场景题：设计判断论文抄袭的系统
堆排序的原理
抽象工厂和工厂方法模式的区别
工厂模式的思想
object类你知道的方法
哪里用到了工厂模式
Forward和redirect的区别
二面（视频）
自我介绍
项目介绍
项目架构
项目难点
Synchronize关键字为什么jdk1.5后效率提高了
线程池的使用时的注意事项
Spring中autowire和resourse关键字的区别
Hashmap的原理
Hashmap的大小为什么指定为2的幂次
讲一下线程状态转移图
消息队列了解么
分布式了解么
阿里作为最想去的公司（毕竟是国内JAVA第一大厂）面试开始比较早，自己还处在面试菜鸟的阶段，最后挂在二面。
一面面试官很好，体验不错。最后给我建议：希望我多去深入理解背后的原理，而不是仅仅停留在知道了解的层面。总体一面还是感觉不错。
二面是整个秋招表现最不好的一次面试。答的很乱。
这次面试看到自己的不足，第一，就是基础很不扎实，很多常问的面试题自己都不知道，第二，要深入去理解背后的原理，比如数据库的隔离级别具体的实现等等，第三，深入琢磨自己做的项目，用一些高大上的技术去装饰。
阿里面试后，有了危机感，从0开始研究redis数据库，研究mysql数据库的一些常问的底层实现，以及spring的一些常见的面试题等
一个经验：到了八九月份的时候，遇到一些自己不会的大块，比如数据库，很多人就直接放弃，觉得再学已经来不及，其实不然，面试的时候，问的东西基本是固定的，只要我们对常问的面试问题深入了解就行。所以八九月份发现自己还有东西完全不会的，也不要慌，沉下心去学几天，绝对来得及！

便利蜂内推（offer）
一面（电话）
自我介绍
项目介绍
volatile和synchronized
来个算法题：一个无序数组，其中一个数字出现的次数大于其他数字之和，求这个数字 （主元素）
答完再来一个：一个数组，有正有负，不改变顺序的情况下，求和最大的最长子序列
项目用到什么数据库？隔离级别？每个隔离级别各做了什么
数据库的索引？mysql不同引擎索引的区别
垃圾回收算法的过程
你了解的垃圾收集器？ Cms收集器的过程
怎样进入老年代？
平时用到了什么设计模式？
讲一下你最熟的两个设计模式
用过什么系统？shell写过脚本吗？
讲你知道的Linux命令
便利蜂是校招拿到的第一个offer，虽然公司名气不大，但尽早拿到第一个offer，可以提高信心和稳住心态，对后续的面试很有帮助。
所以前期一定要多投简历，能面的尽量面，反正最后你又不一定去，多面几次积累经验，等到大厂的面试开始，已经积累到了足够的面试经验，可以发挥的更好。
便利蜂的面试也是幸运女神眷顾。
面试前，在牛客网搜索了所有便利蜂java的面经，只找到一篇，就把那篇面经的问题好好研究了一遍。然后奇迹出现了，面试问的问题基本一模一样，估计是同一个面试官，所以答得很顺利。
一个小技巧，当面试的时候遇到以前做过的算法题的时候，千万别说自己做过，请假装没做过，不然面试官会换题目的。
经验：
进入校招之后，多泡泡牛客网，多看看面经很有帮助，面试其实都大同小异，就那么些知识点，所以多看多总结。

拼多多
一面（现场面）
自我介绍
项目介绍
手撕算法：一棵二叉排序树，给定一个数，找到与给定数差值绝对值最小的数
场景题：设计一个系统，解决抢购时所需要的大量的短链接的功能，如何保证高并发，如何设计短链接
二面（现场面）
代码量多少
给了一张纸，各种名词，会的写出来
然后给它解释那些会的
设计题：设计一个系统，记录qq用户前一天的登录状态，提供16g内存和2tb的硬盘，要做到查询指定qq号的前一天的登录状态，快速查询O(1)复杂度
之前经历了那么多电话面，终于迎来了人生第一次现场技术面！
果然第一次总是会有点痛苦，很遗憾的挂了！
一面感觉还不错，项目简单聊了一下，感觉面试官兴趣不大。就开始手撕代码，第一次手撕代码，略紧张，最后还是想出来了。然后一个场景题，用到了刚学会的redis，现学现卖，感觉面试官还比较满意。
二面一坐下，就感觉对面的面试官气场太强，一坐下，没让自我介绍，直接给了问代码量多少，我准备大概估算一下，结果被面试官打断，让我直接说，讲真，有点慌乱哈哈。就说了大概十万行。然后给了一张纸，大概有几十个专业名词，让我把会的勾出来，然后一个一个的解释。然后就出了一个系统设计题，一直没理解面试官的意思，最后在面试官讨论项目的过程中，面试官问是否可以通过value推到key，一下没经过思考，答了个是，答错了，然后面试官就说面试结束了。
很多时候，如果面试官问到一个比较基础的问题，你没答上来，那你就跪了，所以回答之前要三思熟虑，别急着回答，好好想一想。

多益网络内推（offer）
一面（视频）
自我介绍
对面向对象的理解
介绍多态
Java新建线程有哪几种方式
线程池的作用
看过框架源码么
多益只有一面视频面，是秋招拿到的第二个offer。
整个面试过程，感觉面试官都是问的一些很大的问题，就看你自己发挥了，尽量把知道的都回答，而且尽量回答的专业。
在问到对面向对象的理解的时候，可能大部分人都会回答多态继承封装就没了。前几天正好看到面向对象的六原则和一法则，然后就给面试官吹了一波，面试官也没打断我，一直让我说，整个面试答得比较好的就是这里。
所以还是要提前准备啊，像这种题目，提前准备过和没准备回答出来的效果完全不一样。

涂鸦移动内推（offer）
一面（现场）
自我介绍
项目介绍
数据库的索引原理
索引使用的注意事项
数据库的引擎
Java垃圾回收机制
Java的finalize，finally，final三个关键字的区别和应用场景
String类可以被继承么
手撕算法：假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 当相邻的两个房子同一天被打劫时，该系统会自动报警。
给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，你最多可以得到多少钱 在不触动报警装置的情况下。
二面（电话）
自我介绍
对游戏的了解
项目介绍
算法题：给一个整数数组，找到两个数使得他们的和等于一个给定的数 target。
红黑树
Redis的应用
一面面试官说之前仔细看了我的博客，然后面试的内容就是让我讲一讲博客里写的内容，基本就是之前复习准备的数据库的知识，都游刃有余了。但感觉到自己讲的时候还是思维有点混乱，所以表达能力也很重要，有时间自己试着将一些常问的东西，自己私下表达一遍，尽量做到表达清楚专业有条理。
然后手撕算法，leetcode原题，打劫房屋，自己当时只记得题目，但方法不记得了，就现场推了一遍动态规划的状态方程，结果很幸运推了出来。（这个还是得靠前期的刷题的积累）
二面电话面问的比较简略，又用到了救命稻草redis，发现面试官都很喜欢问这个。可能因为是比较前沿的技术吧，现在企业用的比较多，但实际这个东西不是特别难。所以了解一下redis会很加分。
不久之后，收到涂鸦移动的offer，应该是第四个offer，自己也开始慢慢更有信心了。
虽然最后没去涂鸦，但面试的过程也学习了不少东西，自己在表达能力方面还需要加强。所以每次面试我们或多或少都能有所收获，多面试多经历多体验！

中国电信it研发中心（offer）
一面（现场）
自我介绍
项目介绍
项目里用的什么服务器
自己写一个tomcat服务器，你会怎么写
分布式服务器会出现哪些问题
怎么解决session一致性缓存的问题
Redis的优势和特点
一千万用户并发抢购，怎么设计
如果成功的用户有10万，redis存不下怎么处理
你项目中的难点
二面（现场）
自我介绍
项目介绍
介绍spring中的熟悉的注解
让你实现autowire注解的功能你会如何实现
Redis和mysql的区别
Redis的持久化有哪些方式，具体原理
中国电信算是拿到的第一个比较满意的offer，虽然不是互联网大厂，但是薪资地点发展都感觉不错，当时考虑，如果后面没拿到大厂的offer就去电信养老了。
电信的面试官年纪偏大，问的问题也比较偏实践和设计，基本没问基础知识。
一面一上来就让我写一个tomcat服务器，石化，还好面试官比较和善，慢慢提示我，然后又问我怎么保持session的一致性，这个其实是比较常见的问题，我之前没见过，面试官让我现场想，最后我想到的答案正好是正确答案，然后面试官出的场景题，我就将redis往上面套，无非就是缓存，消息队列这些技术去处理那些高并发的问题。所以答得还不错。
可以看出，有时候面到你不会的东西，如果你能在面试官的引导下回答出来是很加分的，可能因为看到你的思考能力吧，更看重你的潜力！
二面还是聚焦在redis这一块，（redis救命稻草，如果放假在家那几天没看，感觉后面的offer都可能拿不到了）。

中兴（offer）
专业面（现场）
自我介绍
项目介绍
你了解的设计模式，讲两个
Java collection类，集合，讲两个你了解的，说实现原理
Java线程池的作用
你觉得你在你实验室处于什么水平
综合面试（现场）
自我介绍
说一下你知道的设计模式
画一个策略模式的uml图
Java多线程的理解
内存屏障是什么
数据库索引
项目中的优化
然后开始聊人生
中兴软件岗的面试比较水，主要看你的学校背景。学校不错基本没问题

百度（offer）
一面（现场）
自我介绍
Java中的多态
Object类下的方法
Wait和notify的作用
Finalize的作用和使用场景
Hashcode和equals
为什么要同时重写hashcode和equals
不同时重写会出现哪些问题
Hashmap的原理
Hashmap如何变线程安全，每种方式的优缺点
垃圾回收机制
Jvm的参数你知道的说一下
设计模式了解的说一下啊
手撕一个单例模式
快速排序的思想讲一下
给个数组，模拟快排的过程
手写快排
设计题，一个图书馆管理系统，数据库怎么设计，需求自己定，题目很宽泛，面试官看你能考虑到哪些问题
二面（现场）
自我介绍
项目介绍
Redis的特点
分布式事务了解么
反爬虫的机制，有哪些方式
手撕算法：反转单链表
手撕算法：实现类似微博子结构的数据结构，输入一系列父子关系，输出一个类似微博评论的父子结构图
手写java多线程
手写java的soeket编程，服务端和客户端
进程间的通信方式
手撕算法： 爬楼梯，写出状态转移方程
智力题：时针分针什么时候重合
三面（现场）
由于三面面试官不懂java，我不熟c加加，所以全程尬聊
自我介绍
项目介绍
项目难点
手撕算法：给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。
然后继续在这个问题上扩展
求出最短那条的路径
递归求出所有的路径
设计模式讲一下熟悉的
会不会滥用设计模式
多线程条件变量为什么要在while体里，为什么不是if
你遇到什么挫折
百度三轮技术面，每面都在手撕代码，很注重代码能力，还有智力题，也是比较特别的。
一面主要聊了聊基础和写了简单的算法
二面一开始聊了聊项目，然后就开始手撕代码，先撕了翻转单链表（这个算法算是面试常考了，整个秋招写了三次这个算法），然后就撕了一个比较难的算法，微博子结构，代码比较难写，写的比较慢，面试官催了好几次，但还是写出了，面试官评价：“代码风格不错，但是写的太慢，笔试会吃亏”，确实吃亏，笔试挂了好多哈哈。然后又是一轮写，先写多线程，然后写socket，socket不会写，就直接说了。面试的时候，有些问题答不上来也不要慌，最后问了一个智力题，
三面遇到了语言不一样的面试官，于是就一直在写代码。
百度的面试很要求手撕算法的能力，考察的比较全面，智力题场景题均有涉及。

美团内推（offer）
一面（电话）
自我介绍
项目介绍
Redis介绍
了解redis源码么
了解redis集群么
Hashmap的原理
hashmap容量为什么是2的幂次
hashset的源码
object类你知道的方法
hashcode和equals
你重写过hashcode和equals么，要注意什么
假设现在一个学生类，有学号和姓名，我现在hashcode方法重写的时候，只将学号参与计算，会出现什么情况？
往set里面put一个学生对象，然后将这个学生对象的学号改了，再put进去，可以放进set么？并讲出为什么
Redis的持久化？有哪些方式，原理是什么？
讲一下稳定的排序算法和不稳定的排序算法
讲一下快速排序的思想
二面（现场）
自我介绍
讲一下数据的acid
什么是一致性
什么是隔离性
Mysql的隔离级别
每个隔离级别是如何解决
Mysql要加上nextkey锁，语句该怎么写
Java的内存模型，垃圾回收
线程池的参数
每个参数解释一遍
然后面试官设置了每个参数，给了是个线程，让描述出完整的线程池执行的流程
Nio和IO有什么区别
Nio和aio的区别
Spring的aop怎么实现
Spring的aop有哪些实现方式
动态代理的实现方式和区别
Linux了解么
怎么查看系统负载
Cpu load的参数如果为4，描述一下现在系统处于什么情况
Linux，查找磁盘上最大的文件的命令
Linux，如何查看系统日志文件
手撕算法：leeetcode原题 22，Generate Parentheses
三面（现场）
自我介绍
项目介绍
怎么管理项目成员
当意见不一致时，如何沟通开发成员，并举个例子
怎么保证项目的进度
数据库的索引原理
非聚簇索引和聚簇索引
索引的使用注意事项
联合索引
从底层解释最左匹配原则
Mysql对联合索引有优化么？会自动调整顺序么？哪个版本开始优化？
Redis的应用
Redis的持久化的方式和原理
技术选型，一个新技术和一个稳定的旧技术，你会怎么选择，选择的考虑有哪些
说你印象最深的美团技术团队的三篇博客
最近在学什么新技术
你是怎么去接触一门新技术的
会看哪些书
怎么选择要看的书
美团是拿到的第一个大厂offer，也是美团面完后心态更稳了。唉，最有效提升信心的方法就是拿到一个满意的offer！
整个美团流程比较长，由于是内推，9.7号接到电话面，电话面基本聊的基础，面试官很好，一直在引导。
9.20的现场面，二面一开始太紧张，数据库的四个特性不记得了，一个持久性死活想不起来，还好影响不大，后面答的都比较好，问到数据库的隔离级别，我主动引入到底层实现原理，回答问题的时候，可以主动延伸一下，尽量将自己会的表达出来。
面试之前，将牛客网上所有美团的面经扒了下来，看到很多出现率很高的问题，就提前准备了这些问题，果然在面试的时候碰到了，功夫不负有心人，准备工作没有白做。所以多刷牛客，多刷面经才是王道啊！
最后就是手撕算法，leetcode原题，生成括号，dfs问题。一贯套路，假装之前没见过这道题，先讲一个暴力法，然后再写出代码！由于leetcode刷了差不多两遍，所以很顺畅的写出来了。（像这类题，如果之前完全没刷过或者没见过，现场写出来并不容易）
三面就基本就是聊人生，偶尔带一点技术。
现在大厂的面试基本逃不过手写代码，基本上都是leetcode的中等难度的原题或者类似的题目，所以前期一定要多刷题，如果算法能力不强的话，这个只能靠硬实力了。

华为（offer）
一面（现场）
自我介绍
项目介绍
项目架构
项目一个完整的执行流程（由于我是搞java的，而面试官是搞c的，所以全程尬聊）
项目优化
二面（现场）
自我介绍
项目介绍
怎么管理项目进度
平常的爱好
感觉面试官也不是搞java的，所以又是一阵尬聊
华为软件岗的面试比较水，主要看你的学校背景。学校不错基本没问题

苏宁内推（offer）
一面（现场）
自我介绍
项目介绍
面过哪些公司了
有哪些offer了
聊到多益，于是开始聊最近微博上很火的多益老板
得出结论，我和面试官都觉得多益老板三观有问题，但做游戏就是要偏执的人
你博客主要哪方面的
多线程并发包了解么
讲一下countDownLatch
面试过程就是聊人生，面试官先问了你有哪些offer。然后讨论了多益的老板的微博和价值观，估计是因为offer对实力也是一种认可，所以没怎么问技术就结束了，最后顺利拿到offer。（算是秋招拿的最容易的一个offer，就一轮面试聊了聊八卦就过了）但其他认识的同学，有被怼了50分钟技术的。
所以啊，面试这个东西看缘分，期望老天保佑遇到对味的面试官。

腾讯
一面（现场）
自我介绍
项目介绍
Hibernate的作用，你对hibernate的理解
多线程的理解，如何保证线程安全
mysql数据库的引擎和区别
场景题：千万用户抢购，如何处理高并发，并且有一个链接，指向前一天抢购成功的用户，如何设计这个系统和数据库
如果后台处理抢购请求的服务器，每次最多承受200的负载，系统该怎么设计
手撕算法：最小公倍数和最大公约数
二面（现场）
自我介绍
项目介绍
项目里一个完整请求的流程
项目的优化
Hibernate和mybatis的区别
为什么用ssh框架
Mysql的容灾备份
Redis和memcache 的区别
为什么选择redis
Java的full gc
Full gc会导致什么问题
腾讯笔试似乎不怎么刷人（笔试做的很烂，依然收到了面试通知，周围认识的做了腾讯笔试的基本都收到了面试通知）。所以对待腾讯的笔试可以轻松一点。
一面是个小姐姐，基本问的都是很大问题，看你的发挥，没怎么问基础。没想到一面能过，二面是一位中年大叔，不言自威，气场略强，感觉答的还可以，最后还是挂了，可能因为真的不招java吧。
一面的面试官让我回去看一下分布式事务，然后我就真的看了，然后后面网易的面试都在问这个，如果没来面腾讯，估计后面网易也过不了。所以啊，面试真实一个学习的过程，不要错失大好的学习机会

招银网络科技（offer）
一面（现场）
自我介绍
写一个两个有序链表合并成一个有序链表
死锁是什么呢
怎么解决死锁
http请求流程
为什么负载均衡
怎么实现负载均衡
数据库挂了怎么办？除了热备份还有什么方法
讲讲你对spring的理解，不要把ioc和aop背给我听
二面（现场）
自我介绍
项目介绍
算法：找出两个数组相等的数，不能用其他数据结构
算法：给定一个数字，一个数组，找出数组中相加等于这两个数的和，不能用数据结构
算法：如何判断一个树是不是另一颗树的子树
如何解决并发访问的错误
招银算是银行类的公司面试最专业的。
一面上来就是手撕算法，最后问spring的时候，问我对spring的理解，并且面试官提示我不要把ioc和aop背给我听，我就正好讲了自己的理解，ioc和aop都是为了降低代码侵入性和耦合度。所以，有时候一些常规的问题，我们最好能有自己的思考，如果是千篇一律的答案，并没有什么亮点，将自己的理解讲出来或许更好。
二面基本都是在问算法，讲思路就可以了，这个时候就看自己的算法能力了。
前期一定要多刷题！

网易（offer）
一面（现场）
自我介绍
项目介绍
项目难点（疯狂怼）
I++操作是线程安全的么？怎么保证线程安全
场景题：设计一个下单系统，下单成功后可以给用户发优惠券
接上面场景题：服务器挂了，优惠券还没发怎么办
数据库挂了怎么怎么办
怎么保证一致性
分布式事务知道么
介绍分布式事务
你的职业规划
二面（现场）
自我介绍
项目介绍（又是狂怼）
Nio的原理
Channel和buffer
directBuffer和buffer的区别
nio和aio的区别
锁的实现原理
怎么解决缓存和主存的一致性问题
缓存还没更新到主存，服务器挂了怎么办
数据库挂了怎么办
网易的面试感觉运气比较好。也跟自己心态有关，这个时候已经压力不大了，挂了也无所谓，但往往就是这种平常心去面试的时候，发挥的会更好。所以，心态真的很重要。
前两天腾讯面试官让下去了解的分布式事务，结果网易一面的场景题基本都是在这一块讨论，最后还具体问了分布式事务，正好现学现卖。所以，多面试，面试官说让你去了解，一定要去了解，多学习肯定没坏处。二面面试官听说我有博客，对我感觉不错，说很多程序员就缺乏总结的能力。平常积累的博客，感觉终于派上用场了，所以如果有空，维护一个技术博客，写写算法题解或者一些技术问题，就当是学习笔记。

携程（offer）
一面（现场）
自我介绍
项目介绍
项目难点（讲到用了消息队列优化，被面试官夸了一波）
了解hashmap么？讲讲原理
知道java GC？讲讲过程（又背了一遍）
手撕算法，写二叉的后序非递归遍历
手撕算法，翻转单链表
手撕算法，背包问题
携程的迷之测评，但面试还是相对基础，但也要求算法能力。第一个二叉的后序非递归遍历的算法题，算是校招中唯一一个没写出来的算法，不过最后在面试官提示下还是做出来了。

今日头条（offer）
一面（视频）
自我介绍
数据库优化有什么了解
索引的原理
联合索引，如果联合索引（a，b），现在查询a>0,b>0可以用到这个联合索引么？（太久没看，生疏了，答错了，答案应该是不能，只能用到a的索引，范围索引只能用到一列）
数据库优化中，有一个关键字可以分析执行过程，知道么（explain关键字）
Java虚拟机了解么?使用中有什么注意事项？
了解设计模式么？手写一个单例模式
写一个算法吧，一个二维数组，每一行从左到右递增，每一列从上到下递增，给一个数，判断他是否在在二维数组中，在返回下标，不在返回（-1，-1）
比较基础的算法题，要做到最优。
了解nio么？讲一下nio的理解。
Linux命令了解么？查看网络状态的命令，查看内存占用的命令。Awk命令。
二面（视频）
自我介绍
http协议的chunk知道么？是干什么的？
http的状态码了解么？说一下
301和302的区别
502和503的区别（这么久没面，早忘了，然后被面试官教育了一番，说没有真正掌握这些知识）
Redis的数据结构的底层实现
Mysql集群数据是怎么同步的
手撕算法：一个链表，奇数位置递增，偶数位置递减，给链表排序。要求O(n)的时间复杂度
Select，poll，epoll的区别
数据库的索引原理
场景题，设计一个高并发的系统。
三面（视频）
自我介绍
服务器处理接受一个请求的过程
数据库的索引的原理
Innodb都是聚簇索引么？
设计一个文件分发系统，分发到10000台服务器，做到高效可靠，如何保证高效，如何保证可靠
有什么offer
你的优点缺点
你觉得你在同龄中处于什么水平
-------------------------------------------------------------------------------------------------------
1、明确项目是做什么的

2、明确项目的价值。（为什么做这个项目，它解决了用户什么痛点，它带来什么价值？）

3、明确项目的功能。（这个项目涉及哪些功能？）

4、明确项目的技术。（这个项目用到哪些技术？）

5、明确个人在项目中的位置和作用。（你在这个项目的承担角色？）

6、明确项目的整体架构。

7、明确项目的优缺点,如果重新设计你会如何设计。

8、明确项目的亮点。（这个项目有什么亮点？）

9、明确技术成长。（你通过这个项目有哪些技术成长？）

Java基础

1、List 和 Set 的区别

2、HashSet 是如何保证不重复的

3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?

4、HashMap 的扩容过程

5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？

6、final finally finalize

7、强引用 、软引用、 弱引用、虚引用

8、Java反射

9、Arrays.sort 实现原理和 Collection 实现原理

10、LinkedHashMap的应用

11、cloneable接口实现原理

12、异常分类以及处理机制

13、wait和sleep的区别

14、数组在内存中如何分配

Java 并发

1、synchronized 的实现原理以及锁优化？

2、volatile 的实现原理？

3、Java 的信号灯？

4、synchronized 在静态方法和普通方法的区别？

5、怎么实现所有线程在等待某个事件的发生才会去执行？

6、CAS？CAS 有什么缺陷，如何解决？

7、synchronized 和 lock 有什么区别？

8、Hashtable 是怎么加锁的 ？

9、HashMap 的并发问题？

10、ConcurrenHashMap 介绍？1.8 中为什么要用红黑树？

11、AQS

12、如何检测死锁？怎么预防死锁？

13、Java 内存模型？

14、如何保证多线程下 i++ 结果正确？

15、线程池的种类，区别和使用场景？

16、分析线程池的实现原理和线程的调度过程？

17、线程池如何调优，最大数目如何确认？

18、ThreadLocal原理，用的时候需要注意什么？

19、CountDownLatch 和 CyclicBarrier 的用法，以及相互之间的差别?

20、LockSupport工具

21、Condition接口及其实现原理

22、Fork/Join框架的理解

23、分段锁的原理,锁力度减小的思考

24、八种阻塞队列以及各个阻塞队列的特性

Spring

1、BeanFactory 和 FactoryBean？

2、Spring IOC 的理解，其初始化过程？

3、BeanFactory 和 ApplicationContext？

4、Spring Bean 的生命周期，如何被管理的？

5、Spring Bean 的加载过程是怎样的？

6、如果要你实现Spring AOP，请问怎么实现？

7、如果要你实现Spring IOC，你会注意哪些问题？

8、Spring 是如何管理事务的，事务管理机制？

9、Spring 的不同事务传播行为有哪些，干什么用的？

10、Spring 中用到了那些设计模式？

11、Spring MVC 的工作原理？

12、Spring 循环注入的原理？

13、Spring AOP的理解，各个术语，他们是怎么相互工作的？

14、Spring 如何保证 Controller 并发的安全？

Netty

1、BIO、NIO和AIO

2、Netty 的各大组件

3、Netty的线程模型

4、TCP 粘包/拆包的原因及解决方法

5、了解哪几种序列化协议？包括使用场景和如何去选择

6、Netty的零拷贝实现

7、Netty的高性能表现在哪些方面

分布式相关

1、Dubbo的底层实现原理和机制

2、描述一个服务从发布到被消费的详细过程

3、分布式系统怎么做服务治理

4、接口的幂等性的概念

5、消息中间件如何解决消息丢失问题

6、Dubbo的服务请求失败怎么处理

7、重连机制会不会造成错误

8、对分布式事务的理解

9、如何实现负载均衡，有哪些算法可以实现？

10、Zookeeper的用途，选举的原理是什么？

11、数据的垂直拆分水平拆分。

12、zookeeper原理和适用场景

13、zookeeper watch机制

14、redis/zk节点宕机如何处理

15、分布式集群下如何做到唯一序列号

16、如何做一个分布式锁

17、用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗

18、MQ系统的数据如何保证不丢失

19、列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题

20、zookeeper的选举策略

21、全局ID

数据库

1、mysql分页有什么优化

2、悲观锁、乐观锁

3、组合索引，最左原则

4、mysql 的表锁、行锁

5、mysql 性能优化

6、mysql的索引分类：B+，hash；什么情况用什么索引

7、事务的特性和隔离级别

缓存

1、Redis用过哪些数据数据，以及Redis底层怎么实现

2、Redis缓存穿透，缓存雪崩

3、如何使用Redis来实现分布式锁

4、Redis的并发竞争问题如何解决

5、Redis持久化的几种方式，优缺点是什么，怎么实现的

6、Redis的缓存失效策略

7、Redis集群，高可用，原理

8、Redis缓存分片

9、Redis的数据淘汰策略

JVM

1、详细jvm内存模型

2、讲讲什么情况下回出现内存溢出，内存泄漏？

3、说说Java线程栈

4、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？

5、JVM 出现 fullGC 很频繁，怎么去线上排查问题？

6、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？

7、类的实例化顺序

8、JVM垃圾回收机制，何时触发MinorGC等操作

9、JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的

10、各种回收器，各自优缺点，重点CMS、G1

11、各种回收算法

12、OOM错误，stackoverflow错误，permgen space错误